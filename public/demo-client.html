<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>知道引擎 v1.5</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .main-content {
      flex: 1;
      padding-bottom: 12px; /* Match footer padding */
    }
    
    /* Footer styles */
    .footer {
      background-color: #fff;
      border-top: 1px solid #e9ecef;
      padding: 12px 0;
      margin-top: auto;
      text-align: center;
      font-size: 0.9rem;
      color: #6c757d;
    }
    
    .footer a {
      color: #3498db;
      text-decoration: none;
    }
    
    .footer a:hover {
      text-decoration: underline;
    }
    
    h1 {
      color: #2c3e50;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .input-group {
      display: flex;
      gap: 10px;
    }
    input {
      flex: 1;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button {
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background: #2980b9;
    }
    button:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    .nav-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #eee;
      margin-bottom: 20px;
    }
    .nav-title {
      font-size: 24px;
      font-weight: bold;
      color: #2c3e50;
    }
    .nav-links {
      display: flex;
      gap: 20px;
    }
    .nav-link {
      color: #3498db;
      text-decoration: none;
      font-weight: 500;
      padding: 5px 10px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .nav-link:hover {
      background-color: #f8f9fa;
      text-decoration: underline;
    }
    .status {
      padding: 15px;
      background: #f8f9fa;
      border-left: 4px solid #3498db;
      margin-bottom: 10px;
    }
    .status.error {
      border-left-color: #e74c3c;
    }
    .status.success {
      border-left-color: #2ecc71;
    }
    .papers-list {
      margin: 10px 0;
      padding: 0;
    }
    .papers-list li {
      padding: 8px;
      background: #f1f1f1;
      margin-bottom: 5px;
      border-radius: 4px;
      list-style-type: none;
    }
    .papers-list li a {
      color: #3498db;
      text-decoration: none;
    }
    .papers-list li a:hover {
      text-decoration: underline;
    }
    .stream-container {
      white-space: pre-wrap;
      font-family: Georgia, 'Times New Roman', Times, serif;
      padding: 15px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-height: 200px;
      max-height: 500px;
      overflow-y: auto;
    }
    .progress {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .progress-stage {
      padding: 10px;
      background: #ecf0f1;
      border-left: 3px solid #7f8c8d;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .progress-stage.active {
      background: #d5f5e3;
      border-left-color: #2ecc71;
    }
    .progress-stage.completed {
      background: #e8f8f5;
      border-left-color: #1abc9c;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #3498db;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .checkmark {
      display: inline-block;
      width: 20px;
      height: 20px;
      color: #27ae60;
      font-weight: bold;
      text-align: center;
    }
    .citation {
      background-color: #e8f4fc;
      border-radius: 3px;
      padding: 0 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .citation:hover {
      background-color: #c9e3f8;
    }
    .citation.active {
      background-color: #ffeeba;
    }
    .decision-banner {
      padding: 10px 15px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .direct-answer {
      background-color: #d4edda;
      border-left: 5px solid #28a745;
      color: #155724;
    }
    
    .research-needed {
      background-color: #cce5ff;
      border-left: 5px solid #0d6efd;
      color: #004085;
    }
    
    .search-keyword {
      display: inline-block;
      padding: 4px 8px;
      background: #e9f5ff;
      border: 1px solid #b0d7ff;
      border-radius: 15px;
      font-weight: bold;
      color: #0366d6;
      margin: 5px 0;
    }
    
    .paper-item {
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    
    .paper-item.cited {
      border-left: 4px solid #28a745;
    }
    
    .paper-item.unused {
      opacity: 0.7;
    }
    
    .paper-header {
      padding: 10px;
      background: #f8f9fa;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ddd;
    }
    
    .paper-header h4 {
      margin: 0;
      font-size: 16px;
    }
    
    .paper-details {
      padding: 15px;
      display: none;
    }
    
    .paper-details.expanded {
      display: block;
    }
    
    .toggle-icon:after {
      content: "▼";
      font-size: 12px;
    }
    
    .expanded .toggle-icon:after {
      content: "▲";
    }
    
    .meta-info {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .meta-item {
      display: flex;
      align-items: center;
    }
    
    .meta-item i {
      margin-right: 5px;
      opacity: 0.6;
    }
    
    .abstract {
      font-style: italic;
      color: #555;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #eee;
    }
    
    .markdown h1 {
      font-size: 1.8em;
      margin-top: 1em;
      margin-bottom: 0.5em;
    }
    
    .markdown h2 {
      font-size: 1.5em;
      margin-top: 1em;
      margin-bottom: 0.5em;
    }
    
    .markdown h3 {
      font-size: 1.3em;
      margin-top: 0.8em;
      margin-bottom: 0.4em;
    }
    
    .markdown p {
      margin-bottom: 1em;
    }
    
    .markdown ul, .markdown ol {
      margin: 1em 0;
      padding-left: 2em;
    }
    
    .markdown blockquote {
      border-left: 3px solid #ccc;
      margin-left: 0;
      padding-left: 1em;
      color: #666;
    }
    
    .markdown code {
      background-color: #f5f5f5;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: monospace;
    }
    
    .markdown pre {
      background-color: #f5f5f5;
      padding: 1em;
      border-radius: 4px;
      overflow-x: auto;
    }
    
    .markdown table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    
    .markdown th, .markdown td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    
    .markdown th {
      background-color: #f2f2f2;
    }
    
    .paper-tag {
      display: inline-block;
      padding: 3px 6px;
      border-radius: 12px;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .paper-tag.cited {
      background-color: #d4edda;
      color: #155724;
    }
    
    .paper-tag.unused {
      background-color: #e2e3e5;
      color: #383d41;
    }
    
    /* Updated styles for real-time rendering and citations */
    .live-markdown-container {
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      min-height: 250px;
      max-height: 600px;
      overflow-y: auto;
    }
    
    .stream-container {
      display: none; /* Hide the raw text container */
    }
    
    /* Superscript citation style */
    .citation {
      vertical-align: super;
      font-size: 0.75em;
      line-height: 0;
      position: relative;
      background-color: #e9f7fe;
      padding: 3px 5px;
      border-radius: 8px;
      margin: 0 2px;
      cursor: pointer;
      font-weight: bold;
      text-decoration: none;
      color: #0366d6;
      transition: all 0.2s ease;
    }
    
    .citation:hover {
      background-color: #cceeff;
      transform: scale(1.1);
    }
    
    .citation.active {
      background-color: #ffdd57;
    }
    
    /* Add a flash animation for highlighting citations and papers */
    @keyframes flash-highlight {
      0% { background-color: transparent; }
      20% { background-color: #ffff99; }
      100% { background-color: transparent; }
    }
    
    .flash {
      animation: flash-highlight 1.5s ease;
    }

    /* Add style for selected papers */
    .paper-item.selected {
      border-left: 4px solid #9c27b0;
    }
    
    .paper-tag.selected {
      background-color: #e1bee7;
      color: #4a148c;
    }
    
    /* Source badge styles */
    .source-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
      margin-left: 8px;
      color: white;
      vertical-align: middle;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    
    .source-semantic {
      background-color: #1A7BB7;
    }
    
    .source-core {
      background-color: #4CAF50;
    }

    .source-arxiv {
      background-color: #B31B1B;
    }

    .source-ieee {
      background-color: #0072CE;
    }

    .source-pubmed {
      background-color: #336699;
    }
  </style>
  
  <!-- Add Marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div class="main-content">
    <div class="nav-bar">
      <div class="nav-title">知道引擎 v1.5</div>
      <div class="nav-links">
        <a href="subscription.html" class="nav-link">研究订阅</a>
      </div>
    </div>
    
    <div class="container">
      <div class="input-group">
        <input type="text" id="question-input" placeholder="Ask a research question..." />
        <button id="ask-button">Ask Question</button>
      </div>
      
      <div class="progress" id="progress-container" style="display:none;">
        <div class="progress-stage" data-stage="evaluation" id="stage-evaluation">
          <div class="spinner"></div>
          <span>Evaluating question scope...</span>
        </div>
        <div class="progress-stage" data-stage="paper_retrieval" id="stage-paper_retrieval">
          <div class="spinner"></div>
          <span>Searching for relevant papers...</span>
        </div>
        <div class="progress-stage" data-stage="paper_analysis" id="stage-paper_analysis">
          <div class="spinner"></div>
          <span>Analyzing paper content...</span>
        </div>
        <div class="progress-stage" data-stage="answer_generation" id="stage-answer_generation">
          <div class="spinner"></div>
          <span>Generating final answer...</span>
        </div>
      </div>
      
      <div id="papers-container" style="display:none;">
        <h3>Research Papers</h3>
        <ul class="papers-list" id="papers-list"></ul>
      </div>
      
      <div id="status-container" style="display:none;" class="status">
        <p id="status-message">Connecting to server...</p>
      </div>
      
      <div id="answer-container" style="display:none;">
        <h3>Answer</h3>
        <div class="stream-container" id="answer-content"></div>
        <div class="live-markdown-container" id="live-markdown"></div>
      </div>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <p>
        由 <a href="https://github.com/zigaowang/ai-search" target="_blank">知道引擎</a> 提供技术支持 | 
        <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank">GNU GPL v3</a>
        | Copyright &copy; 2025 Zigao Wang, Eason Zheng, Mark Ma, Rebecca Yu
      </p>
    </div>
  </footer>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Check if running from file protocol
      if (window.location.protocol === 'file:') {
        // Create error message
        const errorBox = document.createElement('div');
        errorBox.className = 'status error';
        errorBox.innerHTML = `
          <h3>⚠️ Incorrect Access Method</h3>
          <p>You're opening this file directly from your filesystem, which won't work due to browser security restrictions.</p>
          <p><strong>To use this application:</strong></p>
          <ol>
            <li>Make sure your Node.js server is running: <code>node server.js</code></li>
            <li>Access the application through: <code>http://localhost:3000/</code></li>
          </ol>
        `;
        
        // Insert at the top of the container
        document.querySelector('.container').prepend(errorBox);
        
        // Disable the button
        document.getElementById('ask-button').disabled = true;
        return;
      }
      
      const questionInput = document.getElementById('question-input');
      const askButton = document.getElementById('ask-button');
      const statusContainer = document.getElementById('status-container');
      const statusMessage = document.getElementById('status-message');
      const answerContainer = document.getElementById('answer-container');
      const answerContent = document.getElementById('answer-content');
      const liveMarkdown = document.getElementById('live-markdown');
      const progressContainer = document.getElementById('progress-container');
      const papersContainer = document.getElementById('papers-container');
      const papersList = document.getElementById('papers-list');
      
      let eventSource = null;
      let decisionBanner = null; // Reference to decision banner
      let citationMapping = {}; // Store citation mappings
      let paperElements = {}; // Store references to paper elements
      let accumulatedText = ''; // Store accumulated text for real-time rendering
      
      // Configure markdown parser
      marked.setOptions({
        breaks: true,
        gfm: true
      });
      
      function updateStage(stageName, isActive) {
        const stageElement = document.getElementById(`stage-${stageName}`);
        if (stageElement) {
          if (isActive) {
            stageElement.classList.add('active');
            stageElement.querySelector('.spinner').style.display = 'inline-block';
          } else {
            stageElement.classList.remove('active');
            stageElement.classList.add('completed');
            stageElement.querySelector('.spinner').style.display = 'none';
            
            // Remove existing checkmark if any
            const existingCheckmark = stageElement.querySelector('.checkmark');
            if (existingCheckmark) existingCheckmark.remove();
            
            // Add checkmark
            const checkmark = document.createElement('div');
            checkmark.className = 'checkmark';
            checkmark.innerHTML = '✓';
            stageElement.prepend(checkmark);
          }
        }
      }
      
      function setStatus(message, type = 'info') {
        statusContainer.style.display = 'block';
        statusContainer.className = `status ${type}`;
        statusMessage.textContent = message;
      }
      
      function togglePaperDetails(header) {
        const details = header.nextElementSibling;
        const isExpanded = details.classList.toggle('expanded');
        header.classList.toggle('expanded', isExpanded);
      }
      
      function highlightCitation(citationKey) {
        // Remove active class from all citations
        document.querySelectorAll('.citation.active').forEach(el => {
          el.classList.remove('active');
        });
        
        // Add active class to clicked citation
        document.querySelectorAll(`.citation[data-key="${citationKey}"]`).forEach(el => {
          el.classList.add('active');
        });
        
        // Scroll to corresponding paper if it exists
        const paperElement = paperElements[citationKey];
        if (paperElement) {
          // Ensure papers section is visible
          papersContainer.style.display = 'block';
          
          // Smooth scroll to the paper
          paperElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Flash effect on the paper
          paperElement.classList.remove('flash');
          void paperElement.offsetWidth; // Trigger reflow
          paperElement.classList.add('flash');
          
          // Make sure details are expanded
          const header = paperElement.querySelector('.paper-header');
          const details = paperElement.querySelector('.paper-details');
          if (!details.classList.contains('expanded')) {
            togglePaperDetails(header);
          }
        }
      }
      
      function startStreaming(question) {
        // Reset UI
        answerContent.textContent = '';
        liveMarkdown.innerHTML = '';
        papersList.innerHTML = '';
        answerContainer.style.display = 'none';
        papersContainer.style.display = 'none';
        
        // Reset tracking objects
        citationMapping = {};
        paperElements = {};
        accumulatedText = '';
        
        // Remove any existing decision banner
        if (decisionBanner) {
          decisionBanner.remove();
          decisionBanner = null;
        }
        
        // Show progress tracker
        progressContainer.style.display = 'flex';
        document.querySelectorAll('.progress-stage').forEach(stage => {
          stage.classList.remove('active', 'completed');
          const spinner = stage.querySelector('.spinner');
          if (spinner) spinner.style.display = 'none';
          const checkmark = stage.querySelector('.checkmark');
          if (checkmark) checkmark.remove();
        });
        
        // Disable button during process
        askButton.disabled = true;
        
        // Close any existing connection
        if (eventSource) {
          eventSource.close();
        }
        
        // Connect to SSE endpoint
        const encodedQuestion = encodeURIComponent(question);
        eventSource = new EventSource(`/stream-question?query=${encodedQuestion}`);
        
        setStatus('Connected to server, processing your question...');
        
        // Handle different event types from the server
        eventSource.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            
            switch (data.status) {
              case 'connected':
                setStatus('Connection established, awaiting response...');
                break;
                
              case 'stage_update':
                setStatus(data.message);
                updateStage(data.stage, true);
                break;
                
              case 'papers_finding':
                // Display initial papers as they're being found
                papersContainer.style.display = 'block';
                
                // If this is the first batch, clear the list
                if (papersList.innerHTML === '') {
                  papersList.innerHTML = '';
                }
                
                // Display the papers we have so far
                data.papers.forEach((paper, index) => {
                  displayPaper(paper, index);
                });
                
                setStatus('Finding and processing papers...');
                break;
                
              case 'substage_update':
                if (data.stage === 'evaluation_complete') {
                  // Mark evaluation stage as complete
                  updateStage('evaluation', false);
                  
                  // Create a decision banner
                  decisionBanner = document.createElement('div');
                  decisionBanner.className = `decision-banner ${data.canAnswer ? 'direct-answer' : 'research-needed'}`;
                  decisionBanner.innerHTML = data.canAnswer ? 
                    '<span>✓ This question can be answered directly from my knowledge</span>' :
                    '<span>🔍 Research needed: Searching external sources for information</span>';
                  
                  // Insert after progress container
                  progressContainer.after(decisionBanner);
                  
                  setStatus(data.message);
                }
                else if (data.stage === 'search_term_selected' && data.queryWord) {
                  // Display search keyword
                  if (!decisionBanner) {
                    decisionBanner = document.createElement('div');
                    decisionBanner.className = 'decision-banner research-needed';
                    progressContainer.after(decisionBanner);
                  }
                  
                  const keywordElem = document.createElement('div');
                  keywordElem.innerHTML = `
                    <div>Search keyword: <span class="search-keyword">${data.queryWord}</span></div>
                  `;
                  decisionBanner.appendChild(keywordElem);
                  
                  setStatus(`Using search term: "${data.queryWord}"`);
                }
                else if (data.stage === 'papers_found') {
                  // Display found papers with collapsible details
                  papersContainer.style.display = 'block';
                  papersList.innerHTML = '';
                  
                  data.papers.forEach((paper, index) => {
                    displayPaper(paper, index);
                  });
                  
                  setStatus(`Found ${data.papers.length} relevant papers.`);
                } else if (data.stage === 'filtering_papers') {
                  setStatus(`Evaluating papers for relevance to your question...`, 'info');
                } else if (data.stage === 'papers_selected') {
                  // Update display to indicate which papers were selected
                  setStatus(`Selected ${data.selectedPapers.length} most relevant papers for analysis.`, 'success');
                  
                  // Mark selected papers in the UI
                  data.selectedPapers.forEach(selected => {
                    // Find the paper element by title
                    document.querySelectorAll('.paper-item').forEach(item => {
                      const titleElem = item.querySelector('h4');
                      if (titleElem && titleElem.textContent.includes(selected.title)) {
                        // Mark as selected
                        item.classList.add('selected');
                        const tagElem = item.querySelector('.paper-tag');
                        if (tagElem) {
                          tagElem.textContent = 'Selected';
                          tagElem.classList.add('selected');
                        }
                      }
                    });
                  });
                }
                else {
                  setStatus(data.message);
                }
                break;
              
              case 'streaming':
                // New streaming phase started
                answerContainer.style.display = 'block';
                if (data.stage === 'analyzing_papers') {
                  updateStage('paper_retrieval', false); // Complete previous stage
                  updateStage('paper_analysis', true); // Start current stage
                } else if (data.stage === 'generating_answer') {
                  updateStage('paper_analysis', false); // Complete previous stage
                  updateStage('answer_generation', true); // Start current stage
                }
                break;
                
              case 'token':
                // Individual token from streaming response
                // If this is the first token, make sure container is displayed
                if (!answerContent.textContent) {
                  answerContainer.style.display = 'block';
                }
                
                // Add token to display
                answerContent.textContent += data.token;
                accumulatedText += data.token;
                
                // Update markdown rendering in real-time
                updateMarkdown(accumulatedText);
                
                // Auto-scroll to bottom of rendered content
                liveMarkdown.scrollTop = liveMarkdown.scrollHeight;
                break;
                
              case 'chunk_complete':
                // A chunk of streaming is complete
                if (data.stage === 'generating_answer') {
                  updateStage('answer_generation', false);
                  setStatus('Response complete.', 'success');
                }
                break;
                
              case 'error':
                setStatus(`Error: ${data.error}`, 'error');
                eventSource.close();
                askButton.disabled = false;
                break;
                
              case 'complete':
                // Process complete, clean up
                setStatus('Response complete', 'success');
                eventSource.close();
                askButton.disabled = false;
                
                // Store citation mapping if available
                if (data.result && data.result.citationMapping) {
                  citationMapping = data.result.citationMapping.reduce((acc, item) => {
                    acc[item.key] = item;
                    return acc;
                  }, {});
                  
                  // Mark which papers were cited
                  Object.keys(paperElements).forEach(key => {
                    const paperElement = paperElements[key];
                    const tagElement = paperElement.querySelector('.paper-tag');
                    
                    if (citationMapping[key]) {
                      paperElement.classList.add('cited');
                      paperElement.classList.remove('unused');
                      if (tagElement) {
                        tagElement.textContent = 'Cited';
                        tagElement.classList.remove('unused');
                        tagElement.classList.add('cited');
                      }
                    } else {
                      paperElement.classList.add('unused');
                      if (tagElement) {
                        tagElement.textContent = 'Not cited';
                        tagElement.classList.remove('cited');
                        tagElement.classList.add('unused');
                      }
                    }
                  });
                }
                
                // Process response text - convert markdown and make citations interactive
                const processedText = answerContent.textContent;
                
                // Convert markdown to HTML
                let html = marked.parse(processedText);
                
                // Make citations interactive
                html = html.replace(/\[([A-Za-z]+\d{4})\]/g, (match, key) => {
                  const citationKey = key;
                  const isCited = citationMapping[citationKey];
                  if (isCited) {
                    return `<span class="citation" data-key="${citationKey}" onclick="this.dispatchEvent(new CustomEvent('citation-click', {bubbles: true, detail: {key: '${citationKey}'}}))">
                      [${citationKey}]
                    </span>`;
                  } else {
                    return match; // Keep as-is if not in our mapping
                  }
                });
                
                // Set the processed HTML
                answerContent.innerHTML = html;
                
                // Add listener for citation clicks
                answerContent.addEventListener('citation-click', (e) => {
                  highlightCitation(e.detail.key);
                });
                break;
                
              default:
                console.log('Unknown status:', data);
            }
          } catch (error) {
            console.error('Error parsing event data:', error);
            setStatus('Error processing server response', 'error');
          }
        };
        
        eventSource.onerror = function() {
          setStatus('Connection error. Reconnecting...', 'error');
          // The browser will automatically try to reconnect
        };
      }
      
      // Real-time markdown processing function
      function updateMarkdown(text) {
        // Process citations in text
        let htmlWithCitations = text.replace(/\[([A-Za-z]+\d{4})\]/g, (match, key) => {
          const citationKey = key;
          const isCited = citationMapping[citationKey];
          if (isCited) {
            return `<a class="citation" data-key="${citationKey}" onclick="this.dispatchEvent(new CustomEvent('citation-click', {bubbles: true, detail: {key: '${citationKey}'}}))">
              [${citationKey}]
            </a>`;
          } else {
            return `<span class="citation-placeholder">${match}</span>`;
          }
        });
        
        // Convert markdown to HTML
        const html = marked.parse(htmlWithCitations);
        liveMarkdown.innerHTML = html;
        
        // Add click event listeners to citations
        document.querySelectorAll('.citation').forEach(citation => {
          citation.addEventListener('click', function(e) {
            const key = this.getAttribute('data-key');
            highlightCitation(key);
            e.preventDefault();
          });
        });
      }
      
      function displayPaper(paper, index) {
        const paperItem = document.createElement('li');
        paperItem.className = 'paper-item';
        paperItem.dataset.index = index;
        
        // Create citation key from author and year
        let authorLastName = 'Unknown';
        if (typeof paper.authors === 'string') {
          // Handle string format
          const firstAuthor = paper.authors.split(',')[0];
          authorLastName = firstAuthor ? firstAuthor.split(' ').pop() : 'Unknown';
        } else if (Array.isArray(paper.authors) && paper.authors.length > 0) {
          // Handle array format
          const firstAuthor = paper.authors[0];
          if (typeof firstAuthor === 'string') {
            authorLastName = firstAuthor.split(' ').pop();
          } else if (firstAuthor && typeof firstAuthor === 'object' && firstAuthor.name) {
            authorLastName = firstAuthor.name.split(' ').pop();
          }
        }
        const citationKey = `${authorLastName}${paper.year || ''}`;
        paperItem.dataset.citationKey = citationKey;
        
        // Store reference to this paper element
        paperElements[citationKey] = paperItem;
        
        // Create header (always visible)
        const header = document.createElement('div');
        header.className = 'paper-header';
        
        // Determine source badge
        let sourceBadgeClass = '';
        if (paper.source === 'Semantic Scholar') {
          sourceBadgeClass = 'source-semantic';
        } else if (paper.source === 'CORE') {
          sourceBadgeClass = 'source-core';
        } else if (paper.source === 'arXiv') {
          sourceBadgeClass = 'source-arxiv';
        } else if (paper.source === 'IEEE Xplore') {
          sourceBadgeClass = 'source-ieee';
        } else if (paper.source === 'PubMed') {
          sourceBadgeClass = 'source-pubmed';
        }
        
        const sourceBadge = `<span class="source-badge ${sourceBadgeClass}">${paper.source || 'Unknown'}</span>`;
        
        header.innerHTML = `
          <h4>${paper.title} ${sourceBadge} <span class="paper-tag unused">Not cited yet</span></h4>
          <span class="toggle-icon"></span>
        `;
        header.addEventListener('click', () => togglePaperDetails(header));
        
        // Create details (expandable)
        const details = document.createElement('div');
        details.className = 'paper-details';
        
        // Prepare authors list
        let authorsList = 'Unknown';
        if (typeof paper.authors === 'string') {
          authorsList = paper.authors;
        } else if (Array.isArray(paper.authors) && paper.authors.length > 0) {
          authorsList = paper.authors.map(author => {
            if (typeof author === 'string') return author;
            return author && author.name ? author.name : 'Unknown';
          }).join(', ');
        }
        
        details.innerHTML = `
          <div class="meta-info">
            <div class="meta-item">
              <i>👥</i> Authors: ${authorsList}
            </div>
            <div class="meta-item">
              <i>📅</i> Year: ${paper.year || 'Unknown'}
            </div>
            <div class="meta-item">
              <i>🔗</i> <a href="${paper.link}" target="_blank">View Paper</a>
            </div>
          </div>
          <div class="abstract">
            <strong>Abstract:</strong> ${paper.abstract || 'No abstract available'}
          </div>
        `;
        
        // Append header and details to paper item
        paperItem.appendChild(header);
        paperItem.appendChild(details);
        papersList.appendChild(paperItem);
      }
      
      // Handle form submission
      askButton.addEventListener('click', function() {
        const question = questionInput.value.trim();
        if (question) {
          startStreaming(question);
        } else {
          setStatus('Please enter a question', 'error');
        }
      });
      
      // Allow Enter key to submit
      questionInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          askButton.click();
        }
      });
    });
  </script>
</body>
</html>
